(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{309:function(t,s,a){"use strict";a.r(s);var r=a(10),e=Object(r.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"箭头函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数"}},[t._v("#")]),t._v(" 箭头函数")]),t._v(" "),s("blockquote",[s("p",[t._v("箭头函数表达式的语法比函数表达式更简洁，并且没有自己的 this，arguments，super 或 new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。")])]),t._v(" "),s("h2",{attrs:{id:"使用注意点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用注意点"}},[t._v("#")]),t._v(" 使用注意点")]),t._v(" "),s("p",[t._v("（1）箭头函数没有自己的 this 对象（详见下文）。")]),t._v(" "),s("p",[t._v("（2）不可以当作构造函数，也就是说，不可以对箭头函数使用 new 命令，否则会抛出一个错误。")]),t._v(" "),s("p",[t._v("（3）不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。")]),t._v(" "),s("p",[t._v("（4）不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。")]),t._v(" "),s("p",[s("strong",[t._v("对于普通函数来说，内部的 this 指向函数运行时所在的对象，但是这一点对箭头函数不成立。它没有自己的 this 对象，内部的 this 就是定义时上层作用域中的 this。也就是说，箭头函数内部的 this 指向是固定的，相比之下，普通函数的 this 指向是可变的。")])]),t._v(" "),s("h3",{attrs:{id:"箭头函数没有自己的-this-对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数没有自己的-this-对象"}},[t._v("#")]),t._v(" 箭头函数没有自己的 this 对象")]),t._v(" "),s("blockquote",[s("p",[t._v("普通 function 函数和箭头函数的行为有一个微妙的区别，箭头函数没有它自己的 this 值，箭头函数内的 this 值继承自外围作用域。")])]),t._v(" "),s("h3",{attrs:{id:"箭头函数与非箭头函数间还有一个细微的区别-箭头函数不会获取它们自己的-arguments-对象。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数与非箭头函数间还有一个细微的区别-箭头函数不会获取它们自己的-arguments-对象。"}},[t._v("#")]),t._v(" 箭头函数与非箭头函数间还有一个细微的区别，箭头函数不会获取它们自己的 arguments 对象。")])])}),[],!1,null,null,null);s.default=e.exports}}]);